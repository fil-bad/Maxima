/* [wxMaxima: title   start ]
Procedure Maxima 2019/2020
   [wxMaxima: title   end   ] */


/* [wxMaxima: section start ]
Procedure 1/10/19
   [wxMaxima: section end   ] */


alias(s,sin,c,cos)$

matchdeclare ([a], true)$

let (sin(a), s)$

let (cos(a), c)$

let (asin(a), as)$

let (acos(a), ac)$

let (tan(a), tg)$

Rx(alpha):=matrix(
    [1,0,0],
    [0,c(alpha),-s(alpha)],
    [0,s(alpha),c(alpha)]
)$

Ry(beta):=matrix(
    [c(beta),0,s(beta)],
    [0,1,0],
    [-s(beta),0,c(beta)]
)$

Rz(gamma):=matrix(
    [c(gamma),-s(gamma),0],
    [s(gamma),c(gamma),0],
    [0,0,1]
)$

Rxyz(alpha,beta,gamma):=Rx(alpha).Ry(beta).Rz(gamma)$

Rxzy(alpha,beta,gamma):=Rx(alpha).Ry(beta).Rz(gamma)$

Ryxz(alpha,beta,gamma):=Ry(alpha).Rx(beta).Rz(gamma)$

Ryzx(alpha,beta,gamma):=Ry(alpha).Rz(beta).Rx(gamma)$

Rzxy(alpha,beta,gamma):=Rz(alpha).Rx(beta).Ry(gamma)$

Rzyx(alpha,beta,gamma):=Rz(alpha).Ry(beta).Rx(gamma)$

/* [wxMaxima: section start ]
Procedura 3/10/19
   [wxMaxima: section end   ] */


normaVet(v):=(((v[1])^2+(v[2])^2+(v[3])^2)^(1/2))[1]$

vNorm(v):=(1/normaVet(v))*v$ 

S(omega_x,omega_y,omega_z):=block(
    1/normaVet(transpose([omega_x,omega_y,omega_z]))*matrix(
    [0,-omega_z,omega_y],
    [omega_z,0,-omega_x],
    [-omega_y,omega_x,0]
    ) 
)$

/* Calcolo matrice di rotazione dati vettore e angolo. */

R(v,theta):=block(
    II:diagmatrix(3,1),
    v:rationalize(v),
    assume(normaVet(v)>0),
    vn:vNorm(v),
    Sversore:S(vn[1,1],vn[2,1],vn[3,1]),
    A:s*II-Sversore,
    A1:invert(A),
    theta:theta*normaVet(v),
    A2:matrix(
        [ilt(A1[1,1],s,theta),ilt(A1[1,2],s,theta),ilt(A1[1,3],s,theta)],
        [ilt(A1[2,1],s,theta),ilt(A1[2,2],s,theta),ilt(A1[2,3],s,theta)],
        [ilt(A1[3,1],s,theta),ilt(A1[3,2],s,theta),ilt(A1[3,3],s,theta)]
        )
)$

/* [wxMaxima: section start ]
Procedura 08/10/19
   [wxMaxima: section end   ] */


/* Formula di Rodriguez. */

Rrodr(v,theta):=block(
    II:diagmatrix(3,1),
    v:rationalize(v),
    assume(normaVet(v)>0),
    vn:vNorm(v),
    Svers:S(vn[1,1],vn[2,1],vn[3,1]),
    theta:theta*normaVet(v),
    Rfin: II + sin(theta)*Svers + (1-cos(theta))*(Svers.Svers) 
)$

/* Formula di Rodriguez (calcolo inverso). Data la matrice ricavo vettore e angolo di rotazione. */

/* Verifico che R sia una matrice di rotazione: */

rotVerify(mat):= block(
    assume( is( equal( length(mat), length(transpose(mat) ) ) ) ), /*Matrice quadrata*/
    /* Condizioni per Isometria Diretta */
    assume( is( equal( determinant(mat), 1) ) ),
    assume( is( equal( mat.transpose(mat), diagmatrix(length(mat),1) ) )
))$

/* Determino il vettore di rotazione: */

vetRot(matR):=block( 
    rotVerify(matR),
    Id: diagmatrix(length(matR),1),
    vect: nullspace(matR - Id),
    vr:args(vect)[1]
)$

/* Determino l'angolo di rotazione: */

rapMat(m1,m2):= block(
    [found:0, result: 10], /* Nel nostro caso, 0 <= sin <= 1, */
    for row thru length(m2) do( 
        for col thru length (args(m1)) do(
            if (m2[row][col]#0) 
                then( 
                    found:1,
                    result:m1[row][col]/m2[row][col], 
                    return(result))),
        if is(equal(found,1)) 
            then return(result)
    )
)$

R1: (matrice-transpose(matrice))/2$

R2: S(vNormale[1,1],vNormale[2,1],vNormale[3,1])$

R3: (matrice+transpose(matrice))/2 - diagmatrix (3,1)$

R4: S(vNormale[1,1],vNormale[2,1],vNormale[3,1]) . S(vNormale[1,1],vNormale[2,1],vNormale[3,1])$

seno: rapMat(R1,R2)$

coseno: -rapMat(R3,R4) + 1$

theta: atan2(seno,coseno)$

thetanorm: atan2(seno,coseno) * nv$


